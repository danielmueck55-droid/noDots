<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>No Dots ‚Äì Advent Game</title>

  <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">

  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding-top: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: linear-gradient(#f8f8f8, #d8e3f0);
      background-image:
        url('data:image/svg+xml,%3Csvg width="100" height="100" xmlns="http://www.w3.org/2000/svg"%3E%3Ctext x="10" y="55" font-size="20" fill="%23e0e0e0"%3E‚úª%3C/text%3E%3C/svg%3E'),
        url('data:image/svg+xml,%3Csvg width="120" height="120" xmlns="http://www.w3.org/2000/svg"%3E%3Ctext x="15" y="65" font-size="22" fill="%23f2d4d4"%3E‚ú¶%3C/text%3E%3C/svg%3E');
      background-repeat: repeat;
      overflow-x: hidden;
    }

    h1 {
      font-family: 'Great Vibes', cursive;
      font-size: 3rem;
      color: #b30000;
      margin: 0;
      text-shadow: 0 0 4px rgba(255,255,255,0.7);
    }

    h2 {
      font-family: 'Great Vibes', cursive;
      font-size: 2rem;
      color: #b30000;
      margin: 0;
      text-shadow: 0 0 4px rgba(255,255,255,0.7);
    }

    @media (max-width: 480px) {
      h1 { font-size: 2.4rem; }
      h2 { font-size: 1.9rem; }
    }

    .snowflake {
      position: fixed;
      top: -10px;
      color: white;
      font-size: 20px;
      opacity: 0.75;
      animation: fall linear infinite;
      pointer-events: none;
      z-index: 1000;
    }
    @keyframes fall {
      to { transform: translateY(110vh); }
    }

    /* Top bar */
    #topBar {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      align-items: center;
    }

    .miniLabel {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(255,255,255,0.95);
      padding: 6px 12px;
      border-radius: 999px;
      box-shadow: 0 0 6px rgba(0,0,0,0.15);
      font-size: 15px;
    }

    .miniLabel-title {
      font-weight: 600;
      color: #555;
    }

    #nextColorsContainer {
      display: flex;
      gap: 4px;
    }

    .nextColorBox {
      width: 18px;
      height: 18px;
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,0.15);
      background: #ccc;
    }

    #tutorialBtn {
      padding: 6px 12px;
      border-radius: 999px;
      border: none;
      background: #00897b;
      color: white;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.25);
    }
    #tutorialBtn:active {
      transform: translateY(1px) scale(0.98);
    }

    /* Game frame & board */
    #frame {
      padding: 16px;
      border: 8px solid #b30000;
      border-radius: 20px;
      background: rgba(255,255,255,0.85);
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 95vw;
      position: relative;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 6px;
      width: min(90vw, 320px);
      height: min(90vw, 320px);
      touch-action: none; /* important for mobile swipes */
    }

    .cell {
      border-radius: 12px;
      background: #dcdcdc;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.8),
                  0 1px 2px rgba(0,0,0,0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      transition: background 0.15s ease, transform 0.08s ease, opacity 0.2s ease;
      cursor: pointer;
    }

    .cell.filled {
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,0.85),
        0 2px 4px rgba(0,0,0,0.3);
    }

    .cell:active {
      transform: scale(0.96);
    }

    .cell.disabled {
      cursor: default;
      opacity: 0.6;
    }

    .cell.placedThisTurn {
      animation: popIn 0.2s ease-out;
    }

    @keyframes popIn {
      from { transform: scale(0.6); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .cell.clearing {
      animation: flyUp 0.35s ease-out forwards;
    }

    @keyframes flyUp {
      from { transform: translateY(0); opacity: 1; }
      to { transform: translateY(-18px); opacity: 0; }
    }

    .cell.errorCell {
      animation: wiggle 0.35s ease, fadeOutErr 0.35s ease forwards;
    }

    @keyframes wiggle {
      0% { transform: translateX(0); }
      20% { transform: translateX(-4px); }
      40% { transform: translateX(4px); }
      60% { transform: translateX(-3px); }
      80% { transform: translateX(3px); }
      100% { transform: translateX(0); }
    }

    @keyframes fadeOutErr {
      from { opacity: 1; }
      to { opacity: 0.3; }
    }

    .score-float {
      position: absolute;
      font-size: 14px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 0 4px rgba(0,0,0,0.7);
      animation: floatScore 0.6s ease-out forwards;
    }

    @keyframes floatScore {
      from { transform: translateY(0); opacity: 1; }
      to { transform: translateY(-18px); opacity: 0; }
    }

    /* Game over message */
    #topMessage {
      margin-top: 10px;
      min-height: 1.8em;
      text-align: center;
      font-size: 15px;
      color: #444;
    }

    #finalMessage {
      margin-top: 10px;
      font-size: 1.1rem;
      font-weight: 600;
      text-align: center;
      background: linear-gradient(45deg, #b30000, #d4af37, #008000);
      -webkit-background-clip: text;
      color: transparent;
      text-shadow: 0 0 6px rgba(255,255,255,0.8);
      display: none;
      animation: finalPop 0.7s ease-out;
    }

    @keyframes finalPop {
      0% { transform: scale(0.7); opacity: 0; }
      60% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }

    #restartBtn {
      margin-top: 10px;
      padding: 9px 18px;
      border-radius: 999px;
      border: none;
      background: #b30000;
      color: #fff;
      font-size: 15px;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0,0,0,0.25);
    }
    #restartBtn:active {
      transform: translateY(1px) scale(0.98);
    }
    #restartBtn:hover {
      background: #d00000;
    }

    /* Dancing blocks for game over */
    .cell.dance1 { animation: dance1 0.7s ease-in-out infinite; }
    .cell.dance2 { animation: dance2 0.7s ease-in-out infinite; }
    .cell.dance3 { animation: dance3 0.7s ease-in-out infinite; }

    @keyframes dance1 {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-4px) scale(1.05); }
    }
    @keyframes dance2 {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      50% { transform: translateY(-3px) rotate(-4deg); }
    }
    @keyframes dance3 {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      50% { transform: translateY(-3px) rotate(4deg); }
    }

    /* Tutorial overlay */
    #tutorialOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    #tutorialCard {
      background: #ffffff;
      border-radius: 18px;
      padding: 18px 16px 16px;
      max-width: 320px;
      width: 90vw;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    #tutorialTitle {
      font-family: 'Great Vibes', cursive;
      font-size: 2rem;
      color: #b30000;
      margin-bottom: 4px;
    }

    #tutorialText {
      font-size: 14px;
      color: #555;
      min-height: 2.4em;
    }

    #tutorialMiniBoard {
      margin: 10px auto 8px;
      width: 150px;
      height: 150px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
    }

    .miniCell {
      border-radius: 10px;
      background: #e0e0e0;
      position: relative;
      overflow: hidden;
    }

    .miniDot {
      position: absolute;
      inset: 3px;
      border-radius: 8px;
      opacity: 0;
    }

    .miniDot.show {
      animation: miniPop 0.5s ease-out forwards;
    }

    @keyframes miniPop {
      0% { transform: scale(0.4); opacity: 0; }
      60% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }

    #tutorialControls {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 14px;
    }

    .tutorialBtn {
      border-radius: 999px;
      border: none;
      padding: 6px 10px;
      font-size: 13px;
      cursor: pointer;
      background: #b30000;
      color: white;
    }

    .tutorialBtn.secondary {
      background: #ddd;
      color: #333;
    }
  </style>
</head>
<body>

  <h1>Felice Adventskalender</h1>
  <h2>No Dots Advent Spiel üéÑ</h2>

  <div id="topBar">
    <div class="miniLabel">
      <span class="miniLabel-title">Punkte:</span>
      <span id="score">0</span>
    </div>

    <div class="miniLabel">
      <span class="miniLabel-title">N√§chste Runde:</span>
      <div id="nextColorsContainer"></div>
    </div>

    <button id="tutorialBtn">Tutorial</button>
  </div>

  <div id="frame">
    <div id="board"></div>
    <div id="topMessage"></div>
    <div id="finalMessage"></div>
    <button id="restartBtn">Neu starten</button>
  </div>

  <!-- Tutorial Overlay -->
  <div id="tutorialOverlay">
    <div id="tutorialCard">
      <div id="tutorialTitle">Wie es geht üéÅ</div>
      <div id="tutorialMiniBoard"></div>
      <div id="tutorialText"></div>
      <div id="tutorialControls">
        <button class="tutorialBtn secondary" id="tutorialCloseBtn">Schlie√üen</button>
        <button class="tutorialBtn" id="tutorialNextBtn">Weiter</button>
      </div>
    </div>
  </div>

  <script>
    // Snowflakes
    for (let i = 0; i < 20; i++) {
      const f = document.createElement('div');
      f.className = 'snowflake';
      f.textContent = '‚ùÖ';
      f.style.left = Math.random() * 100 + 'vw';
      f.style.animationDuration = 5 + Math.random() * 5 + 's';
      f.style.animationDelay = Math.random() * 5 + 's';
      document.body.appendChild(f);
    }
  </script>

  <script>
    // =========================
    // GAME STATE & CONSTANTS
    // =========================
    const size = 5; // 5x5 board
    const boardEl = document.getElementById("board");
    const scoreEl = document.getElementById("score");
    const topMessageEl = document.getElementById("topMessage");
    const finalMessageEl = document.getElementById("finalMessage");
    const restartBtn = document.getElementById("restartBtn");
    const nextColorsContainer = document.getElementById("nextColorsContainer");
    const tutorialBtn = document.getElementById("tutorialBtn");

    const tutorialOverlay = document.getElementById("tutorialOverlay");
    const tutorialMiniBoard = document.getElementById("tutorialMiniBoard");
    const tutorialText = document.getElementById("tutorialText");
    const tutorialCloseBtn = document.getElementById("tutorialCloseBtn");
    const tutorialNextBtn = document.getElementById("tutorialNextBtn");

    // Colour palette (we'll unlock more with higher score)
    const ALL_COLORS = [
      "#e74c3c", // red
      "#f1c40f", // yellow
      "#2ecc71", // green
      "#3498db", // blue
      "#9b59b6"  // purple
    ];

    let maxColorsAvailable = 3; // start simple, increase with score
    let board = [];
    let cells = [];
    let score = 0;
    let gameOver = false;

    let currentRoundColors = []; // e.g. [red, yellow, green]
    let placingIndex = 0;        // which colour in this round we are placing
    let placedIndicesThisRound = [];

    // Drag / swipe state
    let isDragging = false;

    // Simple audio using Web Audio API
    let audioCtx = null;
    function initAudio() {
      if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (AudioContext) audioCtx = new AudioContext();
      }
    }

    function playBeep(freq, duration = 0.08) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = freq;
      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.18, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
      osc.start(now);
      osc.stop(now + duration + 0.02);
    }

    function playPlaceSound() { playBeep(550, 0.06); }
    function playMatchSound() { playBeep(320, 0.12); }
    function playErrorSound() { playBeep(160, 0.12); }

    // =========================
    // INITIALIZATION
    // =========================
    function initGame() {
      gameOver = false;
      score = 0;
      scoreEl.textContent = "0";
      topMessageEl.textContent = "";
      finalMessageEl.style.display = "none";
      maxColorsAvailable = 3;

      board = Array(size * size).fill(null);
      boardEl.innerHTML = "";
      cells = [];

      for (let i = 0; i < size * size; i++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.index = i;
        boardEl.appendChild(cell);
        cells.push(cell);
      }

      bindInputEvents();
      nextRound();
    }

    // =========================
    // ROUND / COLORS LOGIC
    // =========================
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function updateMaxColorsFromScore() {
      if (score >= 150) {
        maxColorsAvailable = 5;
      } else if (score >= 80) {
        maxColorsAvailable = 4;
      } else {
        maxColorsAvailable = 3;
      }
    }

    function generateRoundColors() {
      const count = randomInt(1, 4);
      const used = new Set();
      const colors = [];
      const availablePalette = ALL_COLORS.slice(0, maxColorsAvailable);

      while (colors.length < count && colors.length < availablePalette.length) {
        const c = availablePalette[randomInt(0, availablePalette.length - 1)];
        if (!used.has(c)) {
          used.add(c);
          colors.push(c);
        }
      }
      return colors;
    }

    function showNextColors() {
      nextColorsContainer.innerHTML = "";
      currentRoundColors.forEach(c => {
        const box = document.createElement("div");
        box.className = "nextColorBox";
        box.style.background = c;
        nextColorsContainer.appendChild(box);
      });
    }

    function nextRound() {
      updateMaxColorsFromScore();
      currentRoundColors = generateRoundColors();
      placingIndex = 0;
      placedIndicesThisRound = [];
      showNextColors();

      // Check if the new round is even possible (simple Option A: enough empty cells?)
      const emptyCount = board.filter(v => v === null).length;
      if (emptyCount < currentRoundColors.length) {
        // Game over
        finishGame();
      }
    }

    // =========================
    // INPUT HANDLING (MOUSE + TOUCH)
    // =========================
    function bindInputEvents() {
      boardEl.addEventListener("mousedown", pointerDown);
      boardEl.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);

      boardEl.addEventListener("touchstart", pointerDown, { passive: false });
      boardEl.addEventListener("touchmove", pointerMove, { passive: false });
      window.addEventListener("touchend", pointerUp);
      window.addEventListener("touchcancel", pointerUp);
    }

    function getCellIndexFromEvent(e) {
      let clientX, clientY;

      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else if (e.changedTouches && e.changedTouches.length > 0) {
        clientX = e.changedTouches[0].clientX;
        clientY = e.changedTouches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      const target = document.elementFromPoint(clientX, clientY);
      if (!target) return null;
      const cell = target.closest(".cell");
      if (!cell) return null;
      return parseInt(cell.dataset.index, 10);
    }

    function pointerDown(e) {
      if (gameOver) return;
      initAudio(); // first user interaction -> init audio

      if (e.cancelable) e.preventDefault();

      const index = getCellIndexFromEvent(e);
      if (index === null) return;

      if (board[index] !== null) {
        // can't start on a filled cell
        return;
      }

      isDragging = true;
      placedIndicesThisRound = [];
      placingIndex = 0;

      addCellToCurrentPath(index);
    }

    function pointerMove(e) {
      if (!isDragging || gameOver) return;
      if (e.cancelable) e.preventDefault();

      const index = getCellIndexFromEvent(e);
      if (index === null) return;
      addCellToCurrentPath(index);
    }

    function pointerUp(e) {
      if (!isDragging) return;
      isDragging = false;

      // Did we place all colours?
      if (placingIndex < currentRoundColors.length) {
        // Error: not all used
        handlePlacementError();
      } else {
        // Valid placement, resolve matches
        resolveTurn();
      }
    }

    function areAdjacent(a, b) {
      const r1 = Math.floor(a / size), c1 = a % size;
      const r2 = Math.floor(b / size), c2 = b % size;
      return (Math.abs(r1 - r2) + Math.abs(c1 - c2)) === 1;
    }

    function addCellToCurrentPath(index) {
      if (placingIndex >= currentRoundColors.length) return; // already placed all
      if (placedIndicesThisRound.includes(index)) return; // no revisiting
      if (board[index] !== null) return; // can't place on filled

      if (placedIndicesThisRound.length > 0) {
        const last = placedIndicesThisRound[placedIndicesThisRound.length - 1];
        if (!areAdjacent(last, index)) {
          return; // ignore non-adjacent moves
        }
      }

      // Place the next colour
      const color = currentRoundColors[placingIndex];
      board[index] = color;
      placedIndicesThisRound.push(index);
      placingIndex++;

      const cell = cells[index];
      cell.style.background = color;
      cell.classList.add("filled", "placedThisTurn");
      setTimeout(() => cell.classList.remove("placedThisTurn"), 250);

      playPlaceSound();
    }

    // =========================
    // MATCHING & SCORING
    // =========================
    function findMatchingGroups() {
      const visited = Array(board.length).fill(false);
      const groups = [];

      const inBounds = (r, c) => r >= 0 && r < size && c >= 0 && c < size;
      const idx = (r, c) => r * size + c;

      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const startIndex = idx(r, c);
          if (visited[startIndex]) continue;
          const color = board[startIndex];
          if (!color) continue;

          const stack = [startIndex];
          const component = [];
          visited[startIndex] = true;

          while (stack.length > 0) {
            const cur = stack.pop();
            component.push(cur);
            const cr = Math.floor(cur / size);
            const cc = cur % size;

            const neighbours = [
              [cr - 1, cc],
              [cr + 1, cc],
              [cr, cc - 1],
              [cr, cc + 1]
            ];

            for (const [nr, nc] of neighbours) {
              if (!inBounds(nr, nc)) continue;
              const ni = idx(nr, nc);
              if (visited[ni]) continue;
              if (board[ni] === color) {
                visited[ni] = true;
                stack.push(ni);
              }
            }
          }

          if (component.length >= 3) {
            groups.push(component);
          }
        }
      }

      return groups;
    }

    function resolveTurn() {
      const groups = findMatchingGroups();
      if (groups.length === 0) {
        // No combos, just next round
        nextRound();
        return;
      }

      // Flatten and remove duplicates (just in case)
      const indicesToClear = [...new Set(groups.flat())];
      const N = indicesToClear.length;
      const gained = N * N; // NxN scoring

      score += gained;
      scoreEl.textContent = score.toString();
      topMessageEl.textContent = `Kombination! ${N} Bl√∂cke ‚Üí +${gained} Punkte ‚ú®`;
      playMatchSound();

      // Animate "+N" on each cleared block
      indicesToClear.forEach(i => {
        const cell = cells[i];
        cell.classList.add("clearing");
        const label = document.createElement("div");
        label.className = "score-float";
        label.textContent = `+${N}`;
        label.style.left = "50%";
        label.style.top = "50%";
        label.style.transform = "translate(-50%, -50%)";
        cell.appendChild(label);
      });

      // After animation, clear them
      setTimeout(() => {
        indicesToClear.forEach(i => {
          board[i] = null;
          const cell = cells[i];
          cell.classList.remove("clearing", "filled");
          cell.style.background = "#dcdcdc";
          while (cell.firstChild) cell.removeChild(cell.firstChild);
        });

        updateMaxColorsFromScore();
        nextRound();
      }, 420);
    }

    function handlePlacementError() {
      playErrorSound();
      topMessageEl.textContent = "Du musst alle Farben verwenden!";

      placedIndicesThisRound.forEach(i => {
        const cell = cells[i];
        cell.classList.add("errorCell");
      });

      setTimeout(() => {
        // remove the tentative placements
        placedIndicesThisRound.forEach(i => {
          board[i] = null;
          const cell = cells[i];
          cell.classList.remove("errorCell", "filled");
          cell.style.background = "#dcdcdc";
        });
        placedIndicesThisRound = [];
        placingIndex = 0;
        // Keep same colours for this round so they can try again
      }, 380);
    }

    // =========================
    // GAME OVER & DANCE
    // =========================
    function finishGame() {
      gameOver = true;
      topMessageEl.textContent = "";
      finalMessageEl.textContent = `Congrats!! Dein Highscore ist ${score} üéÑ`;
      finalMessageEl.style.display = "block";

      // Make all blocks dance
      cells.forEach((cell, i) => {
        if (board[i] !== null) {
          const rand = Math.floor(Math.random() * 3);
          cell.classList.add(`dance${rand + 1}`);
        }
      });

      if (navigator.vibrate) navigator.vibrate(150);
    }

    restartBtn.addEventListener("click", () => {
      cells.forEach(c => c.classList.remove("dance1", "dance2", "dance3"));
      initGame();
    });

    // =========================
    // TUTORIAL
    // =========================
    const tutorialSteps = [
      {
        text: "Wische √ºber freie Felder, um alle Farben der Runde zu platzieren.",
        colors: ["#e74c3c", "#f1c40f", "#2ecc71"]
      },
      {
        text: "Drei oder mehr gleiche Farben, die sich ber√ºhren, verschwinden.",
        colors: ["#e74c3c", "#e74c3c", "#e74c3c"]
      },
      {
        text: "Je mehr Bl√∂cke du auf einmal kombinierst, desto h√∂her dein Score (N√óN).",
        colors: ["#3498db", "#3498db", "#9b59b6", "#9b59b6"]
      }
    ];
    let tutorialIndex = 0;

    function buildTutorialMiniBoard() {
      tutorialMiniBoard.innerHTML = "";
      for (let i = 0; i < 9; i++) {
        const cell = document.createElement("div");
        cell.className = "miniCell";
        const dot = document.createElement("div");
        dot.className = "miniDot";
        dot.dataset.index = i;
        cell.appendChild(dot);
        tutorialMiniBoard.appendChild(cell);
      }
    }

    function showTutorialStep(idx) {
      const step = tutorialSteps[idx];
      tutorialText.textContent = step.text;

      const dots = tutorialMiniBoard.querySelectorAll(".miniDot");
      dots.forEach(d => {
        d.classList.remove("show");
        d.style.background = "transparent";
      });

      // Very simple fake animation: just show some coloured cells
      if (idx === 0) {
        const seq = [0, 1, 2];
        seq.forEach((pos, i) => {
          const dot = dots[pos];
          dot.style.background = step.colors[i];
          setTimeout(() => dot.classList.add("show"), i * 200);
        });
      } else if (idx === 1) {
        const seq = [3, 4, 5];
        seq.forEach((pos, i) => {
          const dot = dots[pos];
          dot.style.background = "#e74c3c";
          setTimeout(() => dot.classList.add("show"), i * 180);
        });
      } else if (idx === 2) {
        const seq = [6, 7, 8, 5];
        seq.forEach((pos, i) => {
          const dot = dots[pos];
          dot.style.background = step.colors[i] || "#3498db";
          setTimeout(() => dot.classList.add("show"), i * 180);
        });
      }
    }

    tutorialBtn.addEventListener("click", () => {
      tutorialOverlay.style.display = "flex";
      tutorialIndex = 0;
      buildTutorialMiniBoard();
      showTutorialStep(tutorialIndex);
    });

    tutorialCloseBtn.addEventListener("click", () => {
      tutorialOverlay.style.display = "none";
    });

    tutorialNextBtn.addEventListener("click", () => {
      tutorialIndex++;
      if (tutorialIndex >= tutorialSteps.length) {
        tutorialOverlay.style.display = "none";
      } else {
        showTutorialStep(tutorialIndex);
      }
    });

    // =========================
    // START GAME
    // =========================
    initGame();
  </script>
</body>
</html>
